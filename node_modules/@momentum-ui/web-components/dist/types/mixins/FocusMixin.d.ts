/**
 * Copyright (c) Cisco Systems, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/** This mixin provide a different way to show what element is focused.
 * (https://html.spec.whatwg.org/multipage/interaction.html#focus-management-apis)
 * By hiding the native browser outline from component style, we can manage alternative focusing style.
 * Using keyboard this mixin toggle `focus-visible` attribute on compoenent root to show focus ring.
 * This mixin handle `focusin` and `focusout` events because due to this specification
 * (https://w3c.github.io/uievents/#event-type-focusin) this events are composable
 * and they can be handled by one of the targetâ€™s ancestors, which can help us in Shadow DOM event propagation case.
 *
 * Example:
 *
 * @customElements("custom-element")
 * class CustomElement extends FocusMixin(LitElement) {
 *    protected handleFocusIn(event: Event) { <---- You override this with corresponding name in component directly.
        // super.handleFocusIn && super.handleFocusIn(event); <---- Check to see whether the superclass defines a method of the same name, and if so, invoke that method.
        // Do your method work here.
      }
 *    protected handleFocusOut(event: Event) { <---- You override this with corresponding name in component directly.
        // super.handleFocusIn && super.handleFocusIn(event); <---- Check to see whether the superclass defines a method of the same name, and if so, invoke that method.
        // Do your method work here.
      }
 * }
 * */
import { LitElement } from "lit-element";
export declare type AnyConstructor<A = LitElement> = new (...input: any[]) => A;
export declare type FocusEventDetail = {
    sourceEvent: Event;
};
export declare abstract class FocusClass extends LitElement {
    protected setFocus?(force: boolean): void;
    protected handleFocusIn?(event: Event): void;
    protected handleFocusOut?(event: Event): void;
    protected getDeepActiveElement?(): Element;
    protected isElementFocused?(element: HTMLElement): boolean;
    protected manageAutoFocus?(element?: Element): void;
    protected getActiveElement?(): Element | null;
}
export declare const FocusMixin: <T extends AnyConstructor<FocusClass>>(base: T) => T & AnyConstructor<FocusClass>;
