"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var fs = require("fs");
var path = require("path");
var resolve = require("resolve");
var readJson_1 = require("./readJson");
function gatherPeerDependencies(packagePath, options) {
    var peerDeps = [];
    var visitor = function (path, json, deps) {
        peerDeps = peerDeps.concat(deps.peerDependencies);
    };
    walkPackageDependencyTree(packagePath, visitor, [], options);
    // Eliminate duplicates
    return peerDeps.reduce(function (acc, dep) {
        return acc.some(function (dep2) { return isSameDep(dep, dep2); }) ? acc : acc.concat(dep);
    }, []);
}
exports.gatherPeerDependencies = gatherPeerDependencies;
function walkPackageDependencyTree(packagePath, visitor, visitedPaths, options) {
    if (visitedPaths.includes(packagePath)) {
        return;
    }
    visitedPaths.push(packagePath);
    var packageJsonPath = path.join(packagePath, 'package.json');
    if (!fs.existsSync(packageJsonPath)) {
        throw new Error("package.json missing at " + packageJsonPath + ".");
    }
    var packageJson = readJson_1.readJson(packageJsonPath);
    var packageDependencies = getPackageDependencies(packagePath, packageJson);
    if (options.debug) {
        console.log(packageJsonPath);
        packageDependencies.peerDependencies.forEach(function (dep) { return console.log(dep); });
    }
    visitor(packagePath, packageJson, packageDependencies);
    function walkDependency(dependency) {
        if (resolve.isCore(dependency.name)) {
            return;
        }
        var dependencyPath = resolvePackageDir(packagePath, dependency.name);
        if (!dependencyPath) {
            throw new Error("Unable to resolve package " + dependency.name + " from " + packagePath);
        }
        walkPackageDependencyTree(dependencyPath, visitor, visitedPaths, options);
    }
    packageDependencies.dependencies.forEach(walkDependency);
}
exports.walkPackageDependencyTree = walkPackageDependencyTree;
function buildDependencyArray(packagePath, packageJson, dependenciesObject) {
    return Object.keys(dependenciesObject).map(function (name) { return ({
        name: name,
        version: dependenciesObject[name],
        depender: packageJson.name,
        dependerVersion: packageJson.version,
        dependerPath: packagePath
    }); });
}
function getPackageDependencies(packagePath, packageJson) {
    var name = packageJson.name, _a = packageJson.dependencies, dependencies = _a === void 0 ? {} : _a, _b = packageJson.devDependencies, devDependencies = _b === void 0 ? {} : _b, _c = packageJson.peerDependencies, peerDependencies = _c === void 0 ? {} : _c, _d = packageJson.peerDevDependencies, peerDevDependencies = _d === void 0 ? [] : _d;
    var applyPeerDevDependencies = function (dep) {
        return (__assign(__assign({}, dep), { isPeerDevDependency: peerDevDependencies.includes(dep.name) }));
    };
    return {
        packageName: name,
        dependencies: buildDependencyArray(packagePath, packageJson, dependencies),
        devDependencies: buildDependencyArray(packagePath, packageJson, devDependencies),
        peerDependencies: buildDependencyArray(packagePath, packageJson, peerDependencies).map(applyPeerDevDependencies),
        peerDevDependencies: peerDevDependencies
    };
}
exports.getPackageDependencies = getPackageDependencies;
function resolvePackageDir(basedir, packageName) {
    var packagePath;
    // In resolve() v2.x this callback has a different signature
    // function packageFilter(pkg, pkgfile, pkgdir) {
    function packageFilter(pkg, pkgdir) {
        packagePath = pkgdir;
        return pkg;
    }
    try {
        resolve.sync(packageName, { basedir: basedir, packageFilter: packageFilter });
    }
    catch (ignored) {
        // resolve.sync throws if no main: is present
        // Some packages (such as @types/*) do not have a main
        // As long as we have a packagePath, it's fine
    }
    // noinspection JSUnusedAssignment
    return packagePath;
}
exports.resolvePackageDir = resolvePackageDir;
function getInstalledVersion(dep) {
    var peerDependencyDir = resolvePackageDir(".", dep.name);
    if (!peerDependencyDir) {
        return undefined;
    }
    var packageJson = readJson_1.readJson(path.resolve(peerDependencyDir, 'package.json'));
    var isYalc = fs.existsSync(path.resolve(peerDependencyDir, 'yalc.sig'));
    return isYalc ? packageJson.version + "-yalc" : packageJson.version;
}
exports.getInstalledVersion = getInstalledVersion;
function isSameDep(a, b) {
    var keys = [
        "name",
        "version",
        "depender",
        "dependerPath",
        "dependerVersion",
        "installedVersion",
        "semverSatisfies",
        "isYalc",
        "isPeerDevDependency",
    ];
    return keys.every(function (key) { return a[key] === b[key]; });
}
exports.isSameDep = isSameDep;
