#!/usr/bin/env node
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var semver = require("semver");
var shelljs_1 = require("shelljs");
var packageManager_1 = require("./packageManager");
var packageUtils_1 = require("./packageUtils");
var solution_1 = require("./solution");
function getAllNestedPeerDependencies(options) {
    var gatheredDependencies = packageUtils_1.gatherPeerDependencies(".", options);
    function applySemverInformation(dep) {
        var installedVersion = packageUtils_1.getInstalledVersion(dep);
        var semverSatisfies = installedVersion ? semver.satisfies(installedVersion, dep.version) : false;
        var isYalc = !!/-[a-f0-9]+-yalc$/.exec(installedVersion);
        return __assign(__assign({}, dep), { installedVersion: installedVersion, semverSatisfies: semverSatisfies, isYalc: isYalc });
    }
    return gatheredDependencies.map(applySemverInformation);
}
var recursiveCount = 0;
var reportPeerDependencyStatusByDepender = function (dep, options) {
    if (dep.semverSatisfies) {
        if (options.verbose) {
            console.log("  \u2705  " + dep.depender + "@" + dep.dependerVersion + " requires " + dep.name + " " + dep.version + " (" + dep.installedVersion + " is installed)");
        }
    }
    else if (dep.isYalc) {
        console.log("  \u2611\uFE0F  " + dep.depender + "@" + dep.dependerVersion + " requires " + dep.name + " " + dep.version + " (" + dep.installedVersion + " is installed via yalc)");
    }
    else if (dep.installedVersion) {
        console.log("  \u274C  " + dep.depender + "@" + dep.dependerVersion + " requires " + dep.name + " " + dep.version + " (" + dep.installedVersion + " is installed)");
    }
    else {
        console.log("  \u274C  " + dep.depender + "@" + dep.dependerVersion + " requires " + dep.name + " " + dep.version + " (" + dep.name + " is not installed)");
    }
};
var reportPeerDependencyStatusByDependee = function (dep, options) {
    if (dep.semverSatisfies) {
        if (options.verbose) {
            console.log("  \u2705  " + dep.name + " " + dep.version + " is required by " + dep.depender + "@" + dep.dependerVersion + " (" + dep.installedVersion + " is installed)");
        }
    }
    else if (dep.isYalc) {
        console.log("  \u2611\uFE0F  " + dep.name + " " + dep.version + " is required by " + dep.depender + "@" + dep.dependerVersion + " (" + dep.installedVersion + " is installed via yalc)");
    }
    else if (dep.installedVersion) {
        console.log("  \u274C  " + dep.name + " " + dep.version + " is required by " + dep.depender + "@" + dep.dependerVersion + " (" + dep.installedVersion + " is installed)");
    }
    else {
        console.log("  \u274C  " + dep.name + " " + dep.version + " is required by " + dep.depender + "@" + dep.dependerVersion + " (" + dep.name + " is not installed)");
    }
};
function checkPeerDependencies(packageManager, options) {
    var allNestedPeerDependencies = getAllNestedPeerDependencies(options);
    if (options.orderBy === 'depender') {
        allNestedPeerDependencies.sort(function (a, b) { return ("" + a.depender + a.name).localeCompare("" + b.depender + b.name); });
        allNestedPeerDependencies.forEach(function (dep) { return reportPeerDependencyStatusByDepender(dep, options); });
    }
    else if (options.orderBy === 'dependee') {
        allNestedPeerDependencies.sort(function (a, b) { return ("" + a.name + a.depender).localeCompare("" + b.name + b.depender); });
        allNestedPeerDependencies.forEach(function (dep) { return reportPeerDependencyStatusByDependee(dep, options); });
    }
    var problems = allNestedPeerDependencies.filter(function (dep) { return !dep.semverSatisfies && !dep.isYalc; });
    if (!problems.length) {
        console.log('  âœ…  All peer dependencies are met');
        return;
    }
    console.log();
    console.log('Searching for solutions...');
    console.log();
    var resolutions = solution_1.findPossibleResolutions(problems, allNestedPeerDependencies);
    var resolutionsWithSolutions = resolutions.filter(function (r) { return r.resolution; });
    var nosolution = resolutions.filter(function (r) { return !r.resolution; });
    nosolution.forEach(function (solution) {
        var name = solution.problem.name;
        var errorPrefix = "Unable to find a version of " + name + " that satisfies the following peerDependencies:";
        var peerDepRanges = allNestedPeerDependencies.filter(function (dep) { return dep.name === name; })
            .reduce(function (acc, dep) { return acc.includes(dep.version) ? acc : acc.concat(dep.version); }, []);
        console.error("  \u274C  " + errorPrefix + " " + peerDepRanges.join(" and "));
    });
    if (nosolution.length > 0) {
        console.error();
    }
    var commandLines = packageManager_1.getCommandLines(packageManager, resolutionsWithSolutions);
    if (options.install && commandLines.length > 0) {
        console.log('Installing peerDependencies...');
        console.log();
        commandLines.forEach(function (command) {
            console.log("$ " + command);
            shelljs_1.exec(command);
            console.log();
        });
        var newUnsatisfiedDeps = getAllNestedPeerDependencies(options)
            .filter(function (dep) { return !dep.semverSatisfies; })
            .filter(function (dep) { return !nosolution.some(function (x) { return packageUtils_1.isSameDep(x.problem, dep); }); });
        if (nosolution.length === 0 && newUnsatisfiedDeps.length === 0) {
            console.log('All peer dependencies are met');
        }
        if (newUnsatisfiedDeps.length > 0) {
            console.log("Found " + newUnsatisfiedDeps.length + " new unmet peerDependencies...");
            if (++recursiveCount < 5) {
                return checkPeerDependencies(packageManager, options);
            }
            else {
                console.error('Recursion limit reached (5)');
                process.exit(5);
            }
        }
        return;
    }
    else if (commandLines.length > 0) {
        console.log("Install peerDependencies using " + (commandLines.length > 1 ? 'these commands:' : 'this command') + ":");
        console.log();
        commandLines.forEach(function (command) { return console.log(command); });
        console.log();
    }
    process.exit(1);
}
exports.checkPeerDependencies = checkPeerDependencies;
